## TODO обработать в нормальный вид

1. **Indexer (Extractor):**
* **Задача:** Взаимодействие с внешним миром (Solana RPC).
* **Логика:** Обход сигнатур через `getSignaturesForAddress`, получение «тяжелых» данных через `getTransaction` и сохранение их в `raw_data`.
* **Результат:** Записи со статусами `srcGot`/`dstGot`. База наполнена «сырьем».


2. **Processor (Transformer):**
* **Задача:** Бизнес-логика и декодирование.
* **Логика:** Берет `raw_data`, прогоняет через **Borsh**, парсит программные логи, вытаскивает `orderId`. Выполняет **Upsert**, связывая создание и исполнение ордера.
* **Результат:** Статусы `srcReady`/`dstReady`. У нас есть чистые данные об ордерах в БД.


3. **Volumer (Aggregator):**
* **Задача:** Обогащение данными и аналитика.
* **Логика:** Сопоставляет токены с их USD ценой на момент транзакции. Считает агрегаты (daily volume).
* **Результат:** Таблицы-витрины (Materialized Views или отдельные таблицы) для быстрого чтения дашбордом.


4. **Dashboard (Consumer):**
* **Задача:** Визуализация.
* **Логика:** API (Backend) отдает подготовленные агрегаты, UI (Frontend) рисует графики (Created vs Fulfilled).



### Почему это решение — «Ideal»?

* **Restart-safe:** Если упадет `Volumer`, данные в базе никуда не денутся, он просто дорассчитает их после перезапуска.
* **Deterministic:** Если мы решим изменить формулу расчета объема, нам не нужно перепарсивать блокчейн — у нас уже есть все `Ready` данные.
* **Scalable:** Мы можем запустить 10 воркеров `Processor`, если очередь на парсинг станет слишком большой.
